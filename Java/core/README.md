## Абстрактный класс

Класс, помеченный модификатором abstract, называется абстрактным классом. Такие классы могут выступать только предками
для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного
класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Метод, помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе
присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в
других классах. В них же самих описывается лишь некое общее для всех потомков поведение.

## Модификаторы доступа

_private (приватный)_: члены класса доступны только внутри класса. Для обозначения используется служебное слово private.

_default, package-private, package level (доступ на уровне пакета)_: видимость класса/членов класса только внутри
пакета. Является модификатором доступа по умолчанию - специальное обозначение не требуется.

_protected (защищённый)_: члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное
слово protected.

_public (публичный)_: класс/члены класса доступны всем. Для обозначения используется служебное слово public.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

## **Объект Object и его методы**

**Object** это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно,
наследуют его методы:

_public boolean equals(Object obj)_ – служит для сравнения объектов по значению;

_int hashCode()_ – возвращает hash код для объекта;

_String toString()_ – возвращает строковое представление объекта;

_Class getClass()_ – возвращает класс объекта во время выполнения;

_protected Object clone()_ – создает и возвращает копию объекта;

_void notify()_ – возобновляет поток, ожидающий монитор;

_void notifyAll()_ – возобновляет все потоки, ожидающие монитор;

_void wait()_ – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или notifyAll()
для этого объекта;

_void wait(long timeout)_ – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет
метод notify() или notifyAll() для этого объекта;

_void wait(long timeout, int nanos)_ – остановка вызвавшего метод потока на определённое время или пока другой поток не
вызовет метод notify() или notifyAll() для этого объекта;

_protected void finalize()_ – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

## Логические операторы

- &: Логическое AND (И);
- &&: Сокращённое AND;
- |: Логическое OR (ИЛИ);
- ||: Сокращённое OR;
- ^: Логическое XOR (исключающее OR (ИЛИ));
- !: Логическое унарное NOT (НЕ);
- &=: AND с присваиванием;
- |=: OR с присваиванием;
- ^=: XOR с присваиванием;
- ==: Равно;
- !=: Не равно;
- ?:: Тернарный (троичный) условный оператор.

Отличием сокращенных OR и AND является отсутствие выполнения второго условия при однозначности результата

## Побитовые операторы

+ `~`: Побитовый унарный оператор NOT;
+ `&`: Побитовый AND;
+ `&=`: Побитовый AND с присваиванием;
+ `|`: Побитовый OR;
+ `|=`: Побитовый OR с присваиванием;
+ `^`: Побитовый исключающее XOR;
+ `^=`: Побитовый исключающее XOR с присваиванием;
+ `>>`: Сдвиг вправо (деление на 2 в степени сдвига);
+ `>>=`: Сдвиг вправо с присваиванием;
+ `>>>`: Сдвиг вправо без учёта знака;
+ `>>>=`: Сдвиг вправо без учёта знака с присваиванием;
+ `<<`: Сдвиг влево (умножение на 2 в степени сдвига);
+ `<<=`: Сдвиг влево с присваиванием.

## String

Строки являются неизменяемыми в Java. В памяти до Java 9 хранились как массив char, после хранятся как массив байт.
Создать строку возможно двумя способами: через строковый литерал и через конструктор.

- Строковый литерал: _String myString = "hi";_
- Конструктор: _String myString = new String("hi");_ , также есть и другие сигнатуры конструктора

Отличием является то, что строка созданная через конструктор хранится в куче, а через литерал в области кучи - пуле
строк. В пуле строк хранятся уникальные строковые объекты, следовательно при создании строки со значением которое уже
есть в пуле, нам вернется ссылка на уже существующее место в памяти.

Например для следующего кода:
`String str1 = "Hi"; String str2 = "Hi" + " everybody";`
В пуле будут созданы 3 строковых объекта.

Но в данном случае:
`String str1 = "Hi"; String str2 = " everybody"
String str3 = "Hi" + str2;` В пуле будут только два объекта, результат конкатенации окажется в куче, т.к.
интернирование (размещение в пуле строк) происходит на этапе компиляции.

Для решения проблемы в примере выше можем воспользоваться методом intern():
`String str1 = "Hi"; String str2 = " everybody"
String str3 = ("Hi" + str2).intern();` Таким образом строка _"Hi everybody"_ попадет в кучу, а затем уже в рантайме
будет добавлена в пул строк.

На самом деле интернирование не является рекомендуемой операцией из-за дополнительных затрат VM. Рекомендуется
использовать _дедупликацию_. P.s смотреть доклад: https://youtu.be/SZFe3m1DV1A

Разберем **дедупликацию** подробнее.

Строка представляет собой: `private final byte[] value;` Строка неизменяема и мы можем безопасно использовать один
массив value несколькими String. Дедупликация представляет собой не что иное, как переприсваивание виртуальной машиной
адресов поля value. Т. е. мы выполняем дедупликацию не объектов String, а массивов их байт. Поля value нескольких
объектов типа String с одинаковым значением текста изначально ссылаются на разные участки памяти (разные массивы байт),
а после дедупликации будут ссылаться на один и тот же участок памяти, содержащий массив байт.

Сам механизм дедупликации работает в рамках сборки мусора. Для отслеживания уникальных массивов используется
хеш-таблица, и для всех живых строк мы пытаемся переприсвоить массив value на уже существующий такой же массив.

Для включения механизма дедупликации необходимо указать параметр _-XX:+UseStringDeduplication_ и использовать сборщик
мусора G1 (используется с Java 9 по умолчанию)

Опыты показывают, что применение дедупликации строк сокращает расходы кучи на примерно 10%, что в принципе неплохо,
учитывая, что нам не нужно вносить изменение в код

Относитльно строк также важно рассмотреть следующие классы

- Класс _StringBuffer_ изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать
  содержимое.

- Класс _StringBuilder_ был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того, что он не
  синхронизирован и поэтому его методы выполняются значительно быстрей.

Внутри себя они используют массив байт, и взаимодействуют с ним при конкатенации

## Перегрузка и переопредение методов

Переопределение методов происходит, когда child хочет изменить поведение parent класса. Если нужно, чтоб
выполнилось-таки то, что есть в методе parent, можно использовать в child конструкцию вида super.methodName(), что
выполнит работу parent метода, а уже потом добавить логику.

Требования, которые нужно соблюдать:

- сигнатура метода должна быть такая же;
- возвращаемое значение должно быть таким же.

Перегрузка методов — это свойство полиморфизма, в котором при помощи изменения сигнатуры метода можно создать разные
методы для одних действий:

- одно и то же имя метода;
- разные аргументы;
- может быть разный возвращаемый тип. Например, один и тот же add() из ArrayList может быть перегружен следующим образом
  и будет выполнять добавление разным способом, в зависимости от входящих аргументов:
- _add(Object o)_ — просто добавляет объект;
- _add(int index, Object o)_ — добавляет объект в определенный индекс;
- add(Collection<Object> c) — добавляет список объектов;
- add(int index, Collection<Object> c) — добавляет список объектов, начиная с определенного индекса.

## Клонирование объектов

Класс Object содержит protected метод clone(), осуществляющий побитовое копирование объекта производного класса. Однако
сначала необходимо переопределить метод clone() как public для обеспечения возможности его вызова. В переопределенном
методе следует вызвать базовую версию метода super.clone(), которая и выполняет собственно клонирование.

Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс Cloneable. Интерфейс Cloneable не
содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод clone() класса Object
возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод
генерирует исключение CloneNotSupportedException. Следует отметить, что при использовании этого механизма объект
создается без вызова конструктора.

Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их
обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным
типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля
оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам
объект поля класса.

Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс Cloneable и
переопределяет метод clone(). Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда
следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо
наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений
final для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.

## Циклы

В языке Java есть следующие виды циклов:

- for
- while
- do...while

**FOR**

Цикл **for** имеет следующее формальное определение:

``` java
for ([инициализация счетчика]; [условие]; [изменение счетчика])
{
// действия
}
```

Таким образом стандартный вид for имеет следующий вид:

``` java
for (int i = 0; i<9; i++)
{
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}
```

Также допустимо не указывать какой-либо блок в определении или даже не указывать все блоки:

``` java
int i = 1;
for (; ;){
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
    i++;
}
``` 

Цикл без указания блока условия будет выполняться бесконечно. For также может определять сразу несколько переменных:

``` java
int n = 10;
for(int i=0, j = n - 1; i < j; i++, j--){
             
    System.out.println(i * j);
}
``` 

**WHILE**

Цикл while сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:

``` java
int j = 6;
while (j > 0){
    System.out.println(j);
    j--;
}
``` 

**DO-WHILE**

Цикл do сначала выполняет код цикла, а потом проверяет условие в инструкции while. И пока это условие истинно, цикл
повторяется. Например:

``` java
int j = 6;
do {
    System.out.println(j);
    j--;
}
while (j > 0);
``` 

В данном случае код цикла сработает 7 раз, пока j не окажется равным нулю. Важно отметить, что цикл do гарантирует хотя
бы однократное выполнение действий, даже если условие в инструкции while не будет истинно.

**Расширенный for; for-each**

Общая форма цикла типа for-each выглядит так:
_fоr ( тип итер_пер : коллекция) блок_инструкций_
где тип обозначает конкретный тип итер_пер - итерационной переменной, в которой сохраняются поочередно перебираемые
элементы набора данных, обозначенного как коллекция. В данной разновидности цикла for могут быть использованы разные
типы коллекций.

При использовании for-each отпадает необходимость в использовании переменной цикла, задании ее исходного значения и
условия завершения цикла, а также в индексировании массива. В место этого массив автоматически обрабатывается в цикле от
начала до конца. Например:

```java
class Test {
    public static void main(String[] args) {
        int nums[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 1 0};
        int sum = О;
        for (int х : nums) sum += х;
        System.out.println("Полученная сумма: " + sum);
    }
}
```

## Операторы перехода

**Оператор break**

Оператор break позволяет выйти из цикла в любой его момент, даже если цикл не закончил свою работу. Например:

``` java
for (int i = 0; i < 10; i++){
    if (i == 5)
        break;
    System.out.println(i);
}
``` 

Когда счетчик станет равным 5, сработает оператор break, и цикл завершится.

Для break есть еще один сценарий использования, с помощью него мы можем выходить из вложенных циклов, для этого
необходимо определить метку, идентифицирующую некий блок кода. К примеру так:

``` java
public static void main(String[] args) {
    outer:
    for (int i = 0; i < 3; i++) {
      System.out.print("Итерация " + i + ": ");
      for (int j = 0; j < 100; j++) {

        if (j == 10) {
          break outer; // выйти из обоих циклов
        }
        System.out.print(j + " ");
      }
      System.out.println("Эта строка никогда не будет выведена");
    }
    System.out.println("Цикл завершен.");
  }
``` 

**Оператор continue**

Иногда полезно начать очередную итерацию цикла пораньше. То есть нужно продолжить выполнение цикла, но прекратить
обработку остатка кода в его теле для данной частной итерации. Для этого используем оператор continue:

``` java
for (int i = 0; i < 10; i++){
    if (i == 5)
        continue;
    System.out.println(i);
}
``` 

В этом случае, когда выполнение цикла дойдет до числа 5, программа просто пропустит это число и перейдет к следующему,
на следующую итерацию цикла.

Continue также поддерживает метки. Например рассмотрим вывод треугольной таблицы умножения от 0 до 9:

``` java
outer:
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++) {
        if (j > i) {
          System.out.println();
          continue outer;
        }
        System.out.print(" " + (i * j));
      }
    }
    System.out.println();
``` 

Оператор continue в этом примере завершает цикл, вычисляющий j, и продолжает со следующей итерации цикла, управляемого
i.

Важно, что **break** и **continue** выполняют свои функции для всех типов циклов.

**Оператор return**

Оператор управления return используется для явного возврата из метода, т. е. передает программное управление обратно в
вызывающую программу. Оператор return можно использовать в любом месте метода для выполнения перехода обратно в
вызывающую этот метод программу. Оператор return немедленно заканчивает выполнение метода, в котором он находится.
Рассмотрим пример:

``` java
public static void main(String[] args) {
    boolean t = true;
    System.out.println("Перед оператором return.");
    if (t) {
      return; // возврат в вызывающую программу
    }
    System.out.println("Этот оператор никогда не выполнится.");
  }
``` 

Здесь return выполняет возврат к Java-системе во время выполнения, т. к. именно эта система вызывает метод main().

## Рекурсия

В языке Java поддерживается рекурсия - процесс определения чего-либо относительно самого себя.

Применительно к программированию на Java рекурсия - это средство, которое позволяет методу вызывать самого себя. Такой
метод называется рекурсивным.

Классическим примером рекурсии служит вычисление факториала числа. Рассмотрим рекурсивную реализацию:

``` java
class Factorial {
  
    int fact(int n) {
 	int result;
 
  	if(n == 1) return 1;
        result = fact(n - 1) * n;
  
        return result;
    }
}
 
class Recursion {
    public static void main(String args[]) {
       
        Factorial fact = new Factorial();
        System.out.println("Факториал 5 равен " + fact.fact(5));
    }
 
}
``` 

Метод fact() действует следующим образом. Когда этот метод вызывается со значением 1 своего аргумента, возвращается
значение 1. В противном случае возвращается произведение fact(n - 1) * n .

Для вычисления этого выражения метод fact() вызывается со значением n - 1 своего аргумента. Этот процесс повторяется до
тех пор, пока n не станет равным 1, после чего начнется возврат из последовательных вызовов метода fact().

Когда рекурсивный метод вызывает самого себя, новым локальным переменными параметрам **выделяется место** в стеке и код
метода выполняется с этими новыми исходными значениями.

**При каждом возврате** из вызова рекурсивного метода прежние локальные переменные и параметры удаляются из стека, а
выполнение продолжается с точки вызова в самом методе.

Вследствие издержек на дополнительные вызовы рекурсивные варианты многих процедур могут выполняться медленнее их
итерационных аналогов. Слишком большое количество вызовов рекурсивного метода может привести к переполнению стека,
поскольку параметры и локальные переменные сохраняются в стеке, а при каждом новом вызове создаются новые копии этих
значений.

Также при написании рекурсивного алгоритма важно помнить про необходимость условия выхода из рекурсии!

## Аргументы командной строки + var args

Аргументы командной строки передаются методу main(). Аргумент командной строки - это информация, которая во время
запуска программы указывается в командной строке непосредственно после ее имени. Хранятся они в виде символьных строк в
массиве типа String, передаваемые методу main(). Первый аргумент в элементе массива args[0], и так далее.

Рассмотрим пример в котором выводятся все полученные аргументы, с которыми программа вызывается из командной строки:

```java
class ComandLine {
    public static void main(String args[]) {
        for (int i = 0; i < args.length; i++) {
            System.out.println("args[ " + i + "] :" + args[i]);
        }
    }
}
```

**Varargs**
В Jdk5 было внедрено языковое средство для упрощения создания методов, принимающих переменное количество аргументов.

Для указания аргументов переменной длины служат три точки (...). Рассмотрим пример с применением varargs:

```java
class VarArgs {
    static void varTest(int... v) {
        System.out.println("Количество аргументов: " + v.length);
        for (int x : v)
            System.out.println(x + " ");
    }

    public static void main(String[] args) {
        varTest(10);
        varTest(1, 2, 3);
        varTest();
    }
}
```

Переменная v является массивом, при вызове без аргументов длина массива равна 0.

Varargs может быть в сигнатуре метода наряду с обычными параметрами, например:

```java
int foo(int a,int b,int...vals){}
```

**Важно**, что параметр с переменным количеством аргументов должен быть последним.

Также стоит быть осторожным при использовании данной конструкции, т.к. можно получить неоднозначность и ошибку
компиляции, например так:

```java
class VarArgs {
    static void varTest(int... v) {
        System.out.println("Количество аргументов: " + v.length);
        for (int x : v)
            System.out.println(x + " ");
    }

    static void varTest(boolean... v) {
        System.out.println("Количество аргументов: " + v.length);
        for (int x : v)
            System.out.println(x + " ");
    }

    public static void main(String[] args) {
        varTest(1, 2, 3);
        varTest(true, false);
        varTest();//Ошибка: неоднозначность!
    }
}
```

## Передача по ссылке и значению

Существует два способа передачи аргументов в подпрограммы, это **передача по ссылке** и **передача по значению**

Первый из них - это вызов по значению. В таком случае в формальный параметр метода копируется значение аргумента.
Следовательно, изменения , вносимые в параметр метода, никоим образом не сказываются на состоянии аргумента,
используемого при вызове. Вторым способом передачи аргумента является вызов по ссылке. В таком случае параметру метода
передается не значение аргумента, а ссылка на него. В методе данная ссылка используется для доступа к конкретному
аргументу, указанному при вызове. Это означает, что изменения, вносимые в параметр, будут оказывать влияние на аргумент,
используемый при вызове метода. Как будет показано далее, несмотря на то что в Java передача аргументов осуществляется в
соответствии с механизмом вызова по значению, результирующий эффект будет разным для простых и ссылочных типов. Если
методу передается простой тип, например int или douЫe, то он передается по значению. При этом создается копия аргумента,
а то, что происходит с параметром, принимающим аргумент, не распространяется за пределы метода. Рассмотрим в качестве
примера следующую программу.

```java
class Test {
    //Этот метод не может изменить значения аргументов ,передаваемых ему при вызове
    void noChange(int i, int j) {
        i = i + j;
        j = -j;
    }
}

class CallByValue {
    public static void main(String args[]) {
        Test ob = new Test();
        int а = 15, Ь = 20;
        System.out.println(" a и Ь перед вызовом : " +
                а + " " + Ь);
        ob.noChange(a, Ь);
        System.out.println(" a и Ь после вызова : " +
                а + " " + Ь);
    }
}
```

После вызова и перед вызовом значения будут одинаковы, 15 и 20 соответственно.

Если же методу передается объект, то ситуация коренным образом меняется , поскольку объекты передаются неявно, по
ссылке. Вспомн ите, что создание переменной, для которой в качестве типа указан класс, означает создание ссылки на
объект этого класса, и именно эта ссылка передается по значению в формальный параметр при передаче ее методу. Отсюда
следует, что и передаваемый аргумент, и параметр метода, как содержащие одну и ту же ссылку, будут ссылаться на один и
тот же объект. Таким образом, любые изменения объекта в методе будут вызывать соответствующие изменения в объекте,
используемом в качестве аргумента. Для примера рассмотрим следующую программу.

```java
class Test {
    int a, b;

    Test(int i, int j) {
        a = i;
        b = j;
    }

    void change(Test ob) {
        ob.a = ob.a + ob.b;
        ob.b = -ob.b;
    }
}

class CallByRef {
    public static void main(String args[]) {
        Test ob = new Test(15, 20);
        System.out.println(" a и Ь перед вызовом : " +
                ob.а + " " + ob.Ь);
        ob.change(ob);
        System.out.println(" a и Ь после вызова : " +
                ob.а + " " + ob.Ь);
    }
}
```

Выполнение этой программы показывает что значения внутри объекта изменяются после вызова метода.

**NB!** : Простые типы можно передать по ссылке если использовать классы-обертки для простых типов: Float, Integer и
т.д.

## Enum перечисления

В своей простейшей форме перечисление - это сп исок и менован ных кон ­ стант, определяющих новый тип данных. В объектах
перечисл имого типа могут храниться лишь значения, содержащиеся в этом списке. Таким образом, перечислен ия позволяют
определять новый тип дан ных, характеризующийся строго определенным рядом допустимых значений.

Перечисления создаются с использованием ключевого слова enum. Вот так, например, может выглядеть простое перечисление,
представляющее различные виды транспортных средств.

```java
enum Transport {
    CAR, TRUCK, AIRPLANE, TRAIN, ВОАТ
}
```

Идентификаторы CAR, TRUCK и р. - это константы перечисления. Каждый из них нея вно объявлен как открытый (public ),
статический (static) член перечисления Transport.

Определив перечисление, можно создавать переменные этого типа. Однако, несмотря на то что перечисление - это тип класса,
объекты этого класса создаются без применения оператора new. Переменные перечислимого типа создаются подобно переменным
элементарных типов. Например, таким образом:
`Transport tp`

**Методы values() и valueOf()**

Метод values() возвращает массив, содержащий список констант перечисления, а метод valueOf() - константу перечисления,
значение которой соответствует строке str, переданной методу в качестве аргумента. В обоих случаях перечислимый тип -
это тип перечисления. Например, в случае рассмотренного выше перечисления Transport вызов метода Transport.valueOf("
TRAIN")
вернет значение TRAIN типа Transport. Общие сигнатуры методов таковы
`
public static перечислимый_тип[] values()
public static перечислимый_тип valueOf(String str)
`

**Конструкторы, переменные экземпляра и методы**

Перечисление может и меть конструкторы, методы и переменные экземпляра. Если определить для объекта перечислимого типа
конструктор, он будет вызываться всякий раз при создании константы перечисления . Для каждой константы перечислимого
типа можно вызвать любой метод, определенный в перечислении. Кроме того, у каждой константы перечислимого типа и меется
собственная копия любой переменной экземпляра, определенной в перечислении. Ниже приведена переработан ная версия
предыдущей программы, которая демонстрирует использование конструктора, переменной экземпляра, а также метода
перечисления Transport и выводит для каждого вида транспортного средства его типичную скорость движения.

```java
enum Transport {
    CAR(100), TRUCK(80), AIRPLANE(900), TRAIN(120), ВОАТ(40);

    private int speed;

    Transport(int s) {
        speed = s;
    }

    int getSpeed() {
        return speed;
    }
}


class EnumDemo {
    public static void main(String args[]) {
        Transport tp;
        System.out.println("Tипичнaя скорость самолета : " +
                Transport.AIRPLANE.getSpeed());

        System.out.println("Tипичныe скорости движения транспортных средств");
        for (Transport t : Transport.values())
            System.out.println(t + ": " + t.getSpeed() + " км в час ");
    }
}
```

Когда переменная tp объявляется в методе main(),для каждой константы перечисления автоматически вызывается конструктор
Transport(). Числовые значения, передаваемые конструктору Transport() через параметр s, присваиваются переменной speed.
Обратите внимание на то, что список констант перечислимого типа завершается точкой с запятой. Последней в этом списке
указана константа ВОАТ. Точка с запятой требуется в том случае, когда класс перечисления содержит наряду с константами и
другие члены. У каждой константы перечислимого типа и меется собственная копия переменной speed, что позволяет получить
скорость передвижения конкретного транспортного средства, вызвав метод getspeed().

В отношении перечислений действуют два ограничения. Во-первых, перечисление не может быть подклассом другого класса. И
во-вторых, перечисление не может выступать в качестве суперкласса.

## Аннотации

Java предоставляет возможность внедрять в исходный файл дополнительную информацию в виде аннотаций, не изменяя поведения
программы. Эта иформация может быть использована различными инструментальными средствами как на этапе разработки, так и
в процессе развертывания программы. В частности , аннотации могут обрабатываться генератором исходного кода,
компилятором и средствами развертывания приложений. Для обозначения этого языкового средства служит также термин
метаданные, но более описательный термин _аннотация_ употребляется чаще.

Аннотации создаются с помощью механизма, основанного на интерфейсе. Рассмотрим простой пример:

```java
@interface MyAnno {
    String str();

    int val();
}
```

Все аннотации содержат лишь объявления методов без определения их тел . Объявленные методы реализует испол няющая среда
Java, причем они действуют во многом подобно полям. Аннотации всех типов автоматически расширяют интерфейс Annotation.
Следовательно, интерфейс Annotаtion используется в качестве суперинтерфейса для всех аннотаций.

Аннотировать можно классы, поля, методы, параметры и константы перечислимого типа. Также можно аннотировать аннотацию.
Пример аннотирования метода:

```java
@MyAnno(str = "Пример", val = 100)
public static void myMethod(){}
```

**Правила удержания аннотаций**

Правила удержания определяют момент, когда аннотация отбрасывается. В java определены три такие правила:

- SOURCE
- CLASS
- RUNTIME

Аннотации по правилу **source** хранятся только в исходном файле и отбрасываются при компиляции.

Аннотации по правилу **class** сохраняются в файле .class во время компиляции. Но они недоступны для VM во время
выполнения.

Аннотации по правилу **runtime** также сохраняются в файле .class во время компиляции но доступны VM в процессе
выполнения.

Правило удержания задается с помощью встроенной аннотации _@Retention_, рассмотрим пример:

```java

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str();

    int val();
}
```

**Рефлексия**

Аннотации предназначены в основном для использования в инструментальных средствах разработки и развертывания прикладных
программ на Java. Но если они задают правило удержания _Runtime_, то могут быть опрошены во время выполнения с помощью
рефлексии. Рассмотрим пример получения информации из аннотации через рефлексию:

```java

import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str();

    int val();
}

class Meta {
    @MyAnno(str = "Пример", val = 100)
    public static void foo() {
        Meta ob = new Meta();
        try {
            Class<?> c = ob.getClass();
            Method foo = c.getMethod("foo");
            MyAnno annotation = foo.getAnnotation(MyAnno.class);

            System.out.println("str: " + annotation.str() + " val: " + annotation.val());
        } catch (NoSuchMethodException ex) {
            System.out.println("Метод не найден");
        }
    }

    public static void main(String[] args) {
        foo();
    }
}
```

Также существует метод `Annotation[] getAnnotations()` который возвращает все аннотации связанные с объектом

Аннотации также поддерживают значения по умолчанию:

```java

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str() default "Test";

    int val() default 10;
}
``` 

В таком случае при аннотировании мы можем не указывать значения, если нас устраивают значения по умолчанию

Также аннотация может быть **маркерной** - не содержать членов. Или **одночленной** - содержать только один член.

**Встроенные аннотации**

В Java определены встроенные аннотации, рассмотрим их:

**@Retention** - Задает стратегию управления жизненным циклом аннотации. Эта стратегия определяет, будет ли видна
аннотация в исходном коде, скомпилированном файле и в процессе выполнения

**@Documented** - Маркерная аннотация, сообщающая инструментальному средству о том, что аннотация должна
документироваться. Эту аннотацию следует использовать только для аннотирования объявления другой аннотации

**@Target** - Задает виды объявлений, к которым может применяться аннотация. Данная аннотация предназначена только для
использования в отношении другой аннотации. Она получает аргумент в виде константы или массива констант перечисл имого
типа ElementType, таких как CONSTRUCTOR, FIELD и METHOD. Аргумент определяет виды объявлений, к которым может быть
применена аннотация. Отсутствие аннотации @Target указывает на то, что данная аннотация может применяться к любому
объявлению

**@Inherited** - Маркерная аннотация, указывающая на то, что аннотация суперкласса должна наследоваться подклассом

**@Override** - Метод, аннотированный как @Override, должен переопределять метод суперкласса. Если это условие не
выполняется, то возникает ошибка компиляции. Данная аннотация представляет собой маркер и позволяет убедиться в том, что
метод суперкласса действительно переопределен, а не перегружен

**@Deprecated** - Маркерная аннотация, указывающая на то, что объявление устарело и было заменено новым

**@FunctionalInterface** - Маркерная аннотация, используемая для аннотирования объявлений интерфейсов. Она указывает на
то, что аннотируемый ею интерфейс является функциональным интерфейсом, который содержит один и только один абстрактный
метод

**@SafeVarargs** - Маркерная аннотация, которая указывает на то, что в методе или конструкторе не выполняются действия,
небезопасные с точки зрения использования переменного количества аргументов. Может применяться только к статическим или
финальным методам и конструкторам

**@SuppressWarnings** - Указывает на то, что одно ил и более предупреждающих сообщений, которые могут быть сгенерированы
в процессе компиляции, должны подавляться. Подавляемые предупреждающие сообщения задаются именами, представляемыми в
виде строк

**Ограничения для аннотаций**

- Одна аннотация не может наследовать другую
- Все методы объявленные в аннотации не должны иметь параметров
- Должны возвращать примитивный тип, String, Class, Enum, тип другой аннотации или массив вышеперечисленных типов
- Аннотации не могут быть обобщенными
- В аннотациях нельзя указывать оператор throws

## Автоупаковка

В версии JDK 5 были добавлены два очень полезных средства - автоупаковка и автораспаковка, - существенно упрощающие и
ускоряющие создание кода, в котором приходится преобразовывать простые типы данных в объекты и наоборот. Автоупаковка и
автораспаковка непосредственно связаны с оболочками типов и способами помещения значений в экземпляры оболочек и
извлечения значений из них.

**Оболочки типов**

Несмотря на высокую эффективность простых типов, возникают такие ситуации, когда для представления данных желательно
использовать объекты. Например, переменную простого типа нельзя передать методу по ссылке. Кроме того, многие
стандартные структуры данных, реализованные в Java, предполагают работу с объектами, и поэтому в них нельзя хранить
данные простых типов. Для преодоления затруднений, возникающих в подобных и во многих других ситуациях, в Java
предусмотрены оболочки типов - классы, инкапсулирующие простые типы данных.

Оболочки типов реализуются в классах _Double_, _Float_, _Long_, _Integer_, _Short_, _Byte_, _Character_ и _Boolean_,
входящих в пакет java.lang

Чаще всего применяются оболочки типов, представляющие числовые типы данных: _Byte_, _Short_, _Integer_, _Long_, _Float_
и _Double_. Все оболочки числовых типов данных являются производными от абстрактного класса **Number**. В классе Number
определены методы, возвращающие значение объекта для каждого числового типа данных.

- byte byteValue()
- double doubleValue()
- float floatValue()
- int intValue()
- long longValue()
- short shortValue()

В каждом классе оболочки числового типа предусмотрены конструкторы, позволяющие сформировать объект на основе
соответствующего простого типа данных или его строкового представления. Например, в классах Integer и Double имеются
следующие конструкторы. Integer(int num)
Integer(String str)
Double(double num)
Double(String str)
Если параметр str не содержит допустимого строкового представления числового значения , то генерируется исключение **
NumberFormatException**.

**Автоупаковка**

Автоупаковка - это процесс автоматической инкапсуляции (упаковки) простого типа данных в объектную оболочку
соответствующего типа всякий раз, когда в этом возникает необходимость, причем создавать такой объект явным образом не
нужно. Автораспаковка - это обратный процесс автоматического извлечения (распаковки) значения , упакованного в объектную
оболочку. Благодаря автораспаковке отпадает необходимость в вызове таких методов, как intValue() и doubleValue().

Пример автоупаковки:
`Integer i = 100;`, важно что в данном примере объект не создается через new(). Создание объекта происходит
автоматически.

Для распаковки значения из объекта достаточно присвоить переменной простого типа ссылку на этот объект. Например, для
распаковки значения, упакованного в объекте i, нужно ввести в код следующую строку:
`int j = i;`

Автоупаковка и автораспаковка происходят не только в простых операциях присваивания, но и в тех случаях, когда простой
тип требуется преобразовать в объект и наоборот. Следовательно, автоупаковка и автораспаковка могут происходить при
передаче аргумента методу и при возврате значения последним.

Также автоупаковка и автораспаковка происходят в выражениях, например:
`Integer i = 100; i++;` - здесь объект автораспаковывается, увеличивается на единицу и затем снова упаковывается в
объект i