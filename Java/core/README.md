## Абстрактный класс

Класс, помеченный модификатором abstract, называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Метод, помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.

## Модификаторы доступа
_private (приватный)_: члены класса доступны только внутри класса. Для обозначения используется служебное слово private.

_default, package-private, package level (доступ на уровне пакета)_: видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное обозначение не требуется.

_protected (защищённый)_: члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово protected.

_public (публичный)_: класс/члены класса доступны всем. Для обозначения используется служебное слово public.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

## Объект Object и его методы

**Object** это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы:

_public boolean equals(Object obj)_ – служит для сравнения объектов по значению;

_int hashCode()_ – возвращает hash код для объекта;

_String toString()_ – возвращает строковое представление объекта;

_Class getClass()_ – возвращает класс объекта во время выполнения;

_protected Object clone()_ – создает и возвращает копию объекта;

_void notify()_ – возобновляет поток, ожидающий монитор;

_void notifyAll()_ – возобновляет все потоки, ожидающие монитор;

_void wait()_ – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

_void wait(long timeout)_ – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

_void wait(long timeout, int nanos)_ – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

_protected void finalize()_ – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

### Контракт equals
При переопределении метода equals разработчик должен придерживаться основных правил, определенных в спецификации языка Java.
- Рефлексивность\
для любого заданного значения x, выражение x.equals(x) должно возвращать true.
Заданного — имеется в виду такого, что x != null
- Симметричность\
для любых заданных значений x и y, x.equals(y) должно возвращать true только в том случае, когда y.equals(x) возвращает true.
- Транзитивность\
для любых заданных значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, x.equals(z) должно вернуть значение true.
- Согласованность\
для любых заданных значений x и y повторный вызов x.equals(y) будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.
- Сравнение null\
для любого заданного значения x вызов x.equals(null) должен возвращать false.

### Контракт hashcode
Для реализации хэш-функции в спецификации языка определены следующие правила:
- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.

references:
- https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#hashCode()
- https://docs.oracle.com/javase/10/docs/api/java/lang/Object.html#equals(java.lang.Object)
- https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam (больше примеров и информации + алгоритм корректного переопределения)

## Логические операторы
- &: Логическое AND (И);
- &&: Сокращённое AND;
- |: Логическое OR (ИЛИ);
- ||: Сокращённое OR;
- ^: Логическое XOR (исключающее OR (ИЛИ));
- !: Логическое унарное NOT (НЕ);
- &=: AND с присваиванием;
- |=: OR с присваиванием;
- ^=: XOR с присваиванием;
- ==: Равно;
- !=: Не равно;
- ?:: Тернарный (троичный) условный оператор.

Отличием сокращенных OR и AND является отсутствие выполнения второго условия при однозначности результата

## String

Строки являются неизменяемыми в Java. В памяти до Java 9 хранились как массив char, после хранятся как массив байт.
Создать строку возможно двумя способами: через строковый литерал и через конструктор.
- Строковый литерал: _String myString = "hi";_
- Конструктор: _String myString = new String("hi");_ , также есть и другие сигнатуры конструктора

Отличием является то, что строка созданная через конструктор хранится в куче, а через литерал в области кучи - пуле строк.
В пуле строк хранятся уникальные строковые объекты, следовательно при создании строки со значением которое уже есть в пуле, нам вернется ссылка на уже существующее место в памяти.

Например для следующего кода:
`String str1 = "Hi";
String str2 = "Hi" + " everybody";`
В пуле будут созданы 3 строковых объекта.

Но в данном случае:
`String str1 = "Hi";
String str2 = " everybody"
String str3 = "Hi" + str2;` В пуле будут только два объекта, результат конкатенации окажется в куче, т.к. интернирование (размещение в пуле строк) происходит на этапе компиляции.

Для решения проблемы в примере выше можем воспользоваться методом intern():
`String str1 = "Hi";
String str2 = " everybody"
String str3 = ("Hi" + str2).intern();` Таким образом строка _"Hi everybody"_ попадет в кучу, а затем уже в рантайме будет добавлена в пул строк.

На самом деле интернирование не является рекомендуемой операцией из-за дополнительных затрат VM. Рекомендуется использовать _дедупликацию_.

Разберем **дедупликацию** подробнее.

Строка представляет собой: `private final byte[] value;` Строка неизменяема и мы можем безопасно использовать один массив value несколькими String.
Дедупликация представляет собой не что иное, как переприсваивание виртуальной машиной адресов поля value. Т. е. мы выполняем дедупликацию не объектов String, а массивов их байт. Поля value нескольких объектов типа String с одинаковым значением текста изначально ссылаются на разные участки памяти (разные массивы байт), а после дедупликации будут ссылаться на один и тот же участок памяти, содержащий массив байт.

Сам механизм дедупликации работает в рамках сборки мусора. Для отслеживания уникальных массивов используется хеш-таблица, и для всех живых строк мы пытаемся переприсвоить массив value на уже существующий такой же массив.

Для включения механизма дедупликации необходимо указать параметр _-XX:+UseStringDeduplication_ и использовать сборщик мусора G1 (используется с Java 9 по умолчанию)

Опыты показывают, что применение дедупликации строк сокращает расходы кучи на примерно 10%, что в принципе неплохо, учитывая, что нам не нужно вносить изменение в код

Относитльно строк также важно рассмотреть следующие классы
- Класс _StringBuffer_ изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.

- Класс _StringBuilder_ был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.

Внутри себя они используют массив байт, и взаимодействуют с ним при конкатенации

## Перегрузка и переопредение методов

Переопределение методов происходит, когда child хочет изменить поведение parent класса. Если нужно, чтоб выполнилось-таки то, что есть в методе parent, можно использовать в child конструкцию вида super.methodName(), что выполнит работу parent метода, а уже потом добавить логику.

Требования, которые нужно соблюдать:
- сигнатура метода должна быть такая же;
- возвращаемое значение должно быть таким же.

Перегрузка методов — это свойство полиморфизма, в котором при помощи изменения сигнатуры метода можно создать разные методы для одних действий:
- одно и то же имя метода;
- разные аргументы;
- может быть разный возвращаемый тип.
Например, один и тот же add() из ArrayList может быть перегружен следующим образом и будет выполнять добавление разным способом, в зависимости от входящих аргументов:
- _add(Object o)_ — просто добавляет объект;
- _add(int index, Object o)_ — добавляет объект в определенный индекс;
- add(Collection<Object> c) — добавляет список объектов;
- add(int index, Collection<Object> c) — добавляет список объектов, начиная с определенного индекса.

## Клонирование объектов 

Класс Object содержит protected метод clone(), осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод clone() как public для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода super.clone(), которая и выполняет собственно клонирование.

Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс Cloneable. Интерфейс Cloneable не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод clone() класса Object возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение CloneNotSupportedException. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.

Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.

Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс Cloneable и переопределяет метод clone(). Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений final для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.
